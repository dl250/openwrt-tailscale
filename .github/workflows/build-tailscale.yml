name: Smaller Tailscale Build Pipeline

on:
  workflow_dispatch: 
  repository_dispatch:
    types: [ build-tailscale ]

permissions:
  contents: read

env:
  SOFTWARE_NAME: "Tailscale"
  REPO: "tailscale/tailscale"
  REPO_SMALL: "GuNanOvO/openwrt-tailscale"
  REPO_SMALL_NAME: "openwrt-tailscale"
  REPO_SMALL_OWNER: "GuNanOvO"
  ARTIFACT_DIR: "artifacts"
  OPENWRT_IPK_SDK: "24.10.4"
  OPENWRT_APK_SDK: "25.12.0-rc5"

jobs:
  prepare:
    name: Prepare UPX and Go
    runs-on: ubuntu-latest
    outputs:
      upx_ver: ${{ steps.check_upx.outputs.upx_ver }}
      go_version: ${{ steps.check_go.outputs.go_version }}
    steps:
      # ----------------- UPX -----------------
      - name: Check Latest UPX Version
        id: check_upx
        run: |
          UPX_TAG=$(curl -s https://api.github.com/repos/upx/upx/releases/latest \
            | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "UPX_TAG=$UPX_TAG" >> "$GITHUB_ENV"

          UPX_VER="${UPX_TAG#v}"
          echo "Detected UPX Version: $UPX_VER"
          
          echo "upx_ver=$UPX_VER" >> "$GITHUB_OUTPUT"
          echo "UPX_VER=$UPX_VER" >> "$GITHUB_ENV"

      - name: Restore UPX Cache
        id: cache_upx
        uses: actions/cache@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_ver }}

      - name: Prepare UPX
        if: steps.cache_upx.outputs.cache-hit != 'true'
        run: |
          UPX_URL="https://github.com/upx/upx/releases/download/$UPX_TAG/upx-${UPX_VER}-amd64_linux.tar.xz"
          echo "Downloading UPX from: $UPX_URL"
          mkdir -p upx
          curl -L -o upx.tar.xz "$UPX_URL"
          tar -xf upx.tar.xz -C upx --strip-components=1
          chmod +x upx/upx
          rm -f upx.tar.xz

      - name: Save UPX Cache
        if: steps.cache_upx.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_ver }}

      # ----------------- Go -----------------
      - name: Check Latest Go Version
        id: check_go
        run: |
          GO_TAG=$(curl -s https://go.dev/VERSION?m=text | head -1)
          echo "GO_TAG=$GO_TAG" >> "$GITHUB_ENV"

          GO_VER="${GO_TAG#go}"
          echo "Detected Go Version: $GO_VER"
          
          echo "go_version=$GO_VER" >> "$GITHUB_OUTPUT"
          echo "GO_VERSION=$GO_VER" >> "$GITHUB_ENV"

      - name: Restore Go Cache
        id: cache_go
        uses: actions/cache@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

      - name: Prepare Go
        if: steps.cache_go.outputs.cache-hit != 'true'
        run: |
          GO_OS=linux
          GO_ARCH=amd64
          GO_URL="https://go.dev/dl/$GO_TAG.$GO_OS-$GO_ARCH.tar.gz"
          echo "Downloading Go from: $GO_URL"
          mkdir -p go
          curl -L -o go.tar.gz "$GO_URL"
          tar -C go -xzf go.tar.gz --strip-components=1
          rm -f go.tar.gz
      
      - name: Save Go Cache
        if: steps.cache_go.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

  build:
    name: Build for ${{ matrix.platform }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_build_version.outputs.version }}
      date: ${{ steps.get_build_version.outputs.date }}
    needs: prepare
    strategy:
      matrix:
        platform:
          - 'aarch64_cortex-a53'
          - 'aarch64_cortex-a72'
          - 'aarch64_cortex-a76'
          - 'aarch64_generic'
          - 'arm_arm1176jzf-s_vfp'
          - 'arm_arm926ej-s'
          - 'arm_cortex-a15_neon-vfpv4'
          - 'arm_cortex-a5_vfpv4'
          - 'arm_cortex-a7'
          - 'arm_cortex-a7_neon-vfpv4'
          - 'arm_cortex-a7_vfpv4'
          - 'arm_cortex-a8_vfpv3'
          - 'arm_cortex-a9'
          - 'arm_cortex-a9_neon'
          - 'arm_cortex-a9_vfpv3-d16'
          - 'arm_fa526'
          - 'arm_xscale'
          - 'i386_pentium-mmx'
          - 'i386_pentium4'
          - 'loongarch64_generic'
          - 'mips64_mips64r2'
          - 'mips64_octeonplus'
          - 'mips64el_mips64r2'
          - 'mips_24kc'
          - 'mips_4kec'
          - 'mips_mips32'
          - 'mipsel_24kc'
          - 'mipsel_24kc_24kf'
          - 'mipsel_74kc'
          - 'mipsel_mips32'
          - 'riscv64_riscv64'
          - 'x86_64'
      fail-fast: true

    steps:

      # PREPARE TOOLS

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: main
          path: repo

      - name: Set Build Version
        id: get_build_version
        run: |
          VERSION=$(sed -n 's/^PKG_VERSION:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          

          echo "Parsed version: $VERSION"

          echo "Directories prepared:"
          ls -la

      - name: Set Build Timestamp
        id: get_build_date
        run: |
          echo "date=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

      - name: Prepare Build Scripts, Package Files, and Keys
        env:
          USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
          RSA_SECRET_KEY_B64: ${{ secrets.RSA_SECRET_KEY_B64 }}
        run: |
          mkdir build_scripts
          cp repo/build_scripts/*.sh build_scripts/

          mkdir tailscale
          cp -r repo/package/tailscale/. tailscale/
          
          mkdir keys
          echo "$USIGN_SECRET_KEY_B64" | base64 -d > keys/key-build.sec
          echo "$RSA_SECRET_KEY_B64" | base64 -d > keys/key-build.rsa

      - name: Restore UPX Cache
        uses: actions/cache@v4
        id: cache-upx
        with:
          path: upx
          key: upx-linux-amd64-${{ needs.prepare.outputs.upx_ver }}

      - name: Restore Go Cache
        uses: actions/cache@v4
        id: cache-go
        with:
          path: go
          key: go-linux-amd64-${{ needs.prepare.outputs.go_version }}

      - name: Pull OpenWRT 24.10 SDK Docker Image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_IPK_SDK }}

      - name: Pull OpenWRT 25.12 SDK Docker Image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_APK_SDK }}

      # BUILD PACKAGES

      - name: Prepare Directories and Permissions
        run: |
          mkdir -p bin
          mkdir -p "${{ env.ARTIFACT_DIR }}"
          chmod -R 777 bin || true
          echo "Directories prepared with permissions:"
          ls -la

      - name: Build with OpenWRT 24.10 SDK Docker
        run: |
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/build_scripts:/builder/build_scripts:ro,z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "$(pwd)/keys:/builder/keys:ro,z" \
            -v "$(pwd)/upx:/builder/upx:ro,z" \
            -v "$(pwd)/go:/builder/go:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_IPK_SDK }} \
            bash /builder/build_scripts/build_ipk.sh "${{ steps.get_build_version.outputs.version }}" "${{ matrix.platform }}"

      - name: Build with OpenWRT 25.12 SDK Docker
        run: |
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/build_scripts:/builder/build_scripts:ro,z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "$(pwd)/keys:/builder/keys:ro,z" \
            -v "$(pwd)/upx:/builder/upx:ro,z" \
            -v "$(pwd)/go:/builder/go:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_APK_SDK }} \
            bash /builder/build_scripts/build_apk.sh "${{ steps.get_build_version.outputs.version }}" "${{ matrix.platform }}"
        
      - name: Clean Up Build Scripts and Keys
        run: |
          rm -rf build_scripts
          rm -rf tailscale
          rm -rf keys
      
      # UPLOAD ARTIFACTS

      - name: Collect Build Artifacts
        env:
          artifacts: "Packages Packages.gz Packages.sig packages.adb bin.size tailscale_${{  steps.get_build_version.outputs.version }}_${{ matrix.platform }}.ipk tailscale_${{ steps.get_build_version.outputs.version }}_${{ matrix.platform }}.apk"
        run: |
          mkdir -p "${{ env.ARTIFACT_DIR }}/${{ matrix.platform }}"

          for pattern in $artifacts; do
            if [ -f "bin/packages/${{ matrix.platform }}/base/$pattern" ]; then
              echo "Collecting artifact: $pattern"
              cp -v bin/packages/${{ matrix.platform }}/base/$pattern "${{ env.ARTIFACT_DIR }}/${{ matrix.platform }}/" 2>/dev/null || true
            else
              echo "Collecting failed: Artifact not found $pattern"
              exit 0
            fi
          done
          
          echo "Artifact collection attempted for platform: ${{ matrix.platform }}. Contents of artifact directory:"
          ls -la "${{ env.ARTIFACT_DIR }}/${{ matrix.platform }}/"

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: ${{ env.ARTIFACT_DIR }}/
          if-no-files-found: error
          retention-days: 30

  release:
    name: Create Release
    needs: [build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      RELEASE_TAG: v${{ needs.build.outputs.version }}
      RELEASE_VERSION: ${{ needs.build.outputs.version }}
      BUILD_DATE: ${{ needs.build.outputs.date }}
    steps:

      # PREPARE ARTIFACTS
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          path: ${{ env.ARTIFACT_DIR }}
      
      - name: List Downloaded Artifacts
        run: |
          echo "Downloaded artifacts:"
          ls -R ${{ env.ARTIFACT_DIR }}

      # ORGANIZE ARTIFACTS
      
      - name: Organize Artifacts
        run: |
          ARTIFACTS_JSON=${{ env.ARTIFACT_DIR }}/artifacts.json

          echo "[]" > "$ARTIFACTS_JSON"

          for dir in ${{ env.ARTIFACT_DIR }}/*/; do
            # Get the architecture from the directory name
            [ -d "$dir" ] || continue
            dir=${dir%/}
            arch=${dir##*/}

            ipk_path="${{ env.ARTIFACT_DIR }}/${arch}/tailscale_${{ env.RELEASE_VERSION }}_${arch}.ipk"
            apk_path="${{ env.ARTIFACT_DIR }}/${arch}/tailscale_${{ env.RELEASE_VERSION }}_${arch}.apk"

            if [ -f "$ipk_path" ] && [ -f "$apk_path" ]; then
              ipk_name=$(basename "$ipk_path")
              ipk_sha=$(sha256sum "$ipk_path" | awk '{print $1}')
              apk_name=$(basename "$apk_path")
              apk_sha=$(sha256sum "$apk_path" | awk '{print $1}')
              bin_size=$(cat "${{ env.ARTIFACT_DIR }}/${arch}/base/bin.size" 2>/dev/null || echo "unknown")

              # Append metadata to artifacts.json
              jq --arg target "$arch" \
                 --arg ipk "$ipk_name" \
                 --arg ipk_sha "$ipk_sha" \
                 --arg apk "$apk_name" \
                 --arg apk_sha "$apk_sha" \
                 --arg bin_size "$bin_size" \
                 '. += [{target: $target, ipk: $ipk, ipk_sha256: $ipk_sha, apk: $apk, apk_sha256: $apk_sha, bin_size: $bin_size}]' \
                 "$ARTIFACTS_JSON" > "${ARTIFACTS_JSON}.tmp" && mv "${ARTIFACTS_JSON}.tmp" "$ARTIFACTS_JSON"
              
              echo "Added $arch metadata to JSON."
            fi
          done

          echo "${{ env.RELEASE_VERSION }}" > ${{ env.ARTIFACT_DIR }}/version

          # Display the contents of the artifacts directory
          echo "Organized artifacts."

          echo "Contents of artifacts.json:"
          cat ${{ env.ARTIFACT_DIR }}/artifacts.json
          
          echo "Contents of version file:"
          cat ${{ env.ARTIFACT_DIR }}/version
          
          echo "Contents of artifact directory after organization:"
          ls -R ${{ env.ARTIFACT_DIR }}


      # DEPLOY FEED

      - name: Deploy to Feed Branch
        env:
          USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configure Git for committing and pushing changes
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Create a new orphan branch for the feed
          mkdir deploy_workspace
          cd deploy_workspace
          git init

          # Set up remote with authentication using the GITHUB_TOKEN
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          git checkout --orphan feed

          # Fetch the latest main branch to get the feed template
          git fetch origin main --depth=1
          git checkout origin/main -- feed_template/

          # Copy feed template files to the root of the branch
          cp -r feed_template/* ./
          rm -rf feed_template

          # Create .nojekyll to prevent GitHub Pages from ignoring files with underscores
          touch .nojekyll
          
          cp ../${{ env.ARTIFACT_DIR }}/* ./

          # Generate HTML sections for each architecture and insert into index.html
          generate_arch_sections() {
            jq -c '.[]' artifacts.json | while read -r item; do
              arch=$(echo "$item" | jq -r '.target')
              
              echo "<details class=\"arch-section\">"
              echo "    <summary>ðŸ“‚ $arch</summary>"
              echo "    <table>"
              echo "        <thead>"
              echo "            <tr><th>File</th><th>Size</th><th>Sha256Sum</th></tr>"
              echo "        </thead>"
              echo "        <tbody>"
              
              if [ -d "$arch" ]; then
                for file in "$arch"/*; do
                  [ -f "$file" ] || continue
                  fname=$(basename "$file")
                  [ "$fname" == "index.html" ] && continue
                  
                  fsize=$(du -h "$file" | cut -f1)
                  fsha256=$(sha256sum "$file" | cut -d' ' -f1)
                  
                  echo "            <tr>"
                  echo "                <td><a href=\"$arch/$fname\">$fname</a></td>"
                  echo "                <td class=\"size-cell\">$fsize</td>"
                  echo "                <td class=\"sha256-cell\">$fsha256</td>"
                  echo "            </tr>"
                done
              fi
              
              echo "        </tbody>"
              echo "    </table>"
              echo "</details>"
            done
          }
          
          # Use the function to generate sections and insert into index.html
          generate_arch_sections > tbody.tmp

          # Replace the placeholder section in index.html with the generated content
          sed -i '/<!-- arch-section-anchor -->/,/<!-- end-arch-section-anchor -->/ {
            /<!-- arch-section-anchor -->/!{
              /<!-- end-arch-section-anchor -->/!d
            }
          }' index.html
          sed -i '/<!-- arch-section-anchor -->/r tbody.tmp' index.html
          
          # Replace date anchor with the current build date
          current_date="${{ env.BUILD_DATE }}"
          sed -i '/<!-- date-anchor -->/,/<!-- end-date-anchor -->/ {
              /<span id="date">/ {
                  s#<span id="date">.*</span>#<span id="date">'"${current_date}"'</span>#
              }
          }' index.html

          # Replace version anchor with the current release version
          version=$(echo "${{ env.RELEASE_TAG }}" | sed 's/^v//')
          sed -i '/<!-- version-anchor -->/,/<!-- end-version-anchor -->/ {
              /<span id="version">/ {
                  s#<span id="version">.*</span>#<span id="version">'"${version}"'</span>#
              }
          }' index.html

          # Clean up temporary file
          rm -f tbody.tmp

          # Commit and push changes to the feed branch
          git add -A
          git commit -m "Update feed: ${{ env.BUILD_DATE }}"
          git push origin feed --force

      # GENERATE RELEASE

      - name: Generate Release Markdown
        id: generate_release_markdown
        run: |
          # Generate the release body markdown content based on the artifacts.json and other metadata
          artifacts_json="${{ env.ARTIFACT_DIR }}/artifacts.json"
          if [[ ! -f "${artifacts_json}" ]]; then
            echo "Error: artifacts.json missing"
            exit 1
          fi
          
          owner="${{ env.REPO_SMALL_OWNER }}"
          repo="${{ env.REPO_SMALL_NAME }}"
          tag="${{ env.RELEASE_TAG }}"
          
          # Generate markdown table head for release packages
          table="| Target Platform / ç›®æ ‡å¹³å° | IPK Package (OpenWrt) | APK Package (Next-Gen) |\n|:--- |:--- |:--- |"
          
          # Generate markdown table rows for each artifact entry
          rows=$(jq -r --arg owner "$owner" --arg repo "$repo" --arg tag "$tag" '
          .[] | "| \(.target) | [\(.ipk)](https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\(.ipk)) | [\(.apk)](https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\(.apk)) |"
          ' ${artifacts_json})
          
          # Combine table head and rows
          full_table="${table}\n${rows}"

          # Construct the full release body with sections in both Chinese and English, including the generated table
          release_body="
          ## Smaller Tailscale / æ›´å°çš„Tailscale  
          #### Version / ç‰ˆæœ¬ : ${{ env.RELEASE_TAG }}
          #### Build Date / æž„å»ºæ—¥æœŸ : ${{ env.BUILD_DATE }}
          #### Upstream Changelog / ä¸Šæ¸¸æ›´æ–°æ—¥å¿— : [https://tailscale.com/changelog](https://tailscale.com/changelog)
          ---

          #### æœ¬é¡¹ç›®æ˜¯ä¸º OpenWRT æž„å»ºçš„ Tailscale ç²¾ç®€ç‰ˆæœ¬ï¼Œä½¿ç”¨å®˜æ–¹ SDK ç¼–è¯‘ï¼Œæ—¨åœ¨é™ä½Žå­˜å‚¨ç©ºé—´å ç”¨ã€‚    
          - ä½¿ç”¨ OpenWRT å®˜æ–¹ SDK ç¼–è¯‘ã€‚  
          - é‡‡ç”¨ UPX åŽ‹ç¼©æŠ€æœ¯å¤§å¹…ç¼©å°äºŒè¿›åˆ¶ä½“ç§¯ã€‚  
          - æ ‡å‡† IPKã€APK åŒ…ï¼Œæ”¯æŒ opkgã€apk ç›´æŽ¥å®‰è£…ã€‚  

          #### Minimalistic Tailscale build for OpenWRT using the official SDK.  
          - Compiled with official OpenWRT SDK.  
          - Significant size reduction via UPX compression.  
          - Standard IPK, APK packages for direct opkg, apk installation.  

          #### Architecture Check / æž¶æž„æŸ¥è¯¢  
          Openwrt 24.10 or earlier / æˆ–æ›´æ—©ç‰ˆæœ¬ï¼š:  
          \`\`\`bash
          opkg print-architecture
          \`\`\`

          Openwrt 25.12 or later / æˆ–æ›´é«˜ç‰ˆæœ¬ï¼š:
          \`\`\`bash
          apk --print-arch
          \`\`\`
          ---
        
          #### Download Links / ä¸‹è½½æ¸…å•
          > [!IMPORTANT]
          > è¯·æ ¹æ®è®¾å¤‡æž¶æž„ä¸Žopenwrtç‰ˆæœ¬é€‰æ‹©å¯¹åº”çš„å®‰è£…åŒ…ã€‚
          > OpenWrt 24.10æˆ–æ›´æ—©ç‰ˆæœ¬è¯·ä½¿ç”¨ .ipk åŒ…ï¼ŒOpenWrt 25.12æˆ–æ›´é«˜ç‰ˆæœ¬è¯·ä½¿ç”¨ .apk åŒ…ã€‚
          > Please select the correct package for your device architecture.
          > Use .ipk for OpenWrt 24.10 or earlier, and .apk for OpenWrt 25.12 or later.

          <details open>
          <summary>Package List / æ–‡ä»¶åˆ—è¡¨</summary>

          ${full_table}

          </details>
          "

          # Output the release body to be used in the next step
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo -e "${release_body}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # PUBLISH RELEASE

      - name: Publish Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: "Smaller ${{ env.SOFTWARE_NAME }} ${{ env.RELEASE_TAG }}"
          body: ${{ steps.generate_release_markdown.outputs.release_body }}
          files: |
            ${{ env.ARTIFACT_DIR }}/*.ipk
            ${{ env.ARTIFACT_DIR }}/*.apk
            ${{ env.ARTIFACT_DIR }}/artifacts.json
            ${{ env.ARTIFACT_DIR }}/version

      # SYNC REPO

      - name: Sync to Repo
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.git.createTag({
              owner: '${{ env.REPO_SMALL_OWNER }}',
              repo: '${{ env.REPO_SMALL_NAME }}',
              tag: '${{ env.RELEASE_TAG }}',
              message: 'Release ${{ env.RELEASE_TAG }}',
              object: '${{ github.sha }}',
              type: 'commit'
            })