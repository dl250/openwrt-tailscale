name: Smaller Tailscale Build Pipeline

on:
  workflow_dispatch: 
  repository_dispatch:
    types: [ build-tailscale ]

permissions:
  contents: read

env:
  SOFTWARE_NAME: "Tailscale"
  REPO: "tailscale/tailscale"
  REPO_SMALL: "GuNanOvO/openwrt-tailscale"
  REPO_SMALL_NAME: "openwrt-tailscale"
  REPO_SMALL_OWNER: "GuNanOvO"
  ARTIFACT_DIR: "artifacts"
  OPENWRT_IPK_SDK: "24.10.4"
  OPENWRT_APK_SDK: "25.12.0-rc5"

jobs:
  prepare-tools:
    name: Prepare UPX and Go
    runs-on: ubuntu-latest
    outputs:
      upx_ver: ${{ steps.check_upx.outputs.upx_ver }}
      go_version: ${{ steps.check_go.outputs.go_version }}
    steps:
      # ----------------- UPX -----------------
      - name: Check Latest UPX Version
        id: check_upx
        run: |
          UPX_TAG=$(curl -s https://api.github.com/repos/upx/upx/releases/latest \
            | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "UPX_TAG=$UPX_TAG" >> "$GITHUB_ENV"

          UPX_VER="${UPX_TAG#v}"
          echo "Detected UPX Version: $UPX_VER"
          
          echo "upx_ver=$UPX_VER" >> "$GITHUB_OUTPUT"
          echo "UPX_VER=$UPX_VER" >> "$GITHUB_ENV"

      - name: Restore UPX Cache
        id: cache_upx
        uses: actions/cache@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_ver }}

      - name: Prepare UPX
        if: steps.cache_upx.outputs.cache-hit != 'true'
        run: |
          UPX_URL="https://github.com/upx/upx/releases/download/$UPX_TAG/upx-${UPX_VER}-amd64_linux.tar.xz"
          echo "Downloading UPX from: $UPX_URL"
          mkdir -p upx
          curl -L -o upx.tar.xz "$UPX_URL"
          tar -xf upx.tar.xz -C upx --strip-components=1
          chmod +x upx/upx
          rm -f upx.tar.xz

      - name: Save UPX Cache
        if: steps.cache_upx.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: upx
          key: upx-linux-amd64-${{ steps.check_upx.outputs.upx_ver }}

      # ----------------- Go -----------------
      - name: Check Latest Go Version
        id: check_go
        run: |
          GO_TAG=$(curl -s https://go.dev/VERSION?m=text | head -1)
          echo "GO_TAG=$GO_TAG" >> "$GITHUB_ENV"

          GO_VER="${GO_TAG#go}"
          echo "Detected Go Version: $GO_VER"
          
          echo "go_version=$GO_VER" >> "$GITHUB_OUTPUT"
          echo "GO_VERSION=$GO_VER" >> "$GITHUB_ENV"

      - name: Restore Go Cache
        id: cache_go
        uses: actions/cache@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

      - name: Prepare Go
        if: steps.cache_go.outputs.cache-hit != 'true'
        run: |
          GO_OS=linux
          GO_ARCH=amd64
          GO_URL="https://go.dev/dl/$GO_TAG.$GO_OS-$GO_ARCH.tar.gz"
          echo "Downloading Go from: $GO_URL"
          mkdir -p go
          curl -L -o go.tar.gz "$GO_URL"
          tar -C go -xzf go.tar.gz --strip-components=1
          rm -f go.tar.gz
      
      - name: Save Go Cache
        if: steps.cache_go.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: go
          key: go-linux-amd64-${{ steps.check_go.outputs.go_version }}

  build:
    name: Build for ${{ matrix.platform }}
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_build_version.outputs.version }}
      date: ${{ steps.get_build_version.outputs.date }}
    needs: prepare-tools
    strategy:
      matrix:
        # sdk:
        #   - '24.10.4'
        #   - '25.12.0-rc5'
        platform:
          # - 'aarch64_cortex-a53'
          # - 'aarch64_cortex-a72'
          # - 'aarch64_cortex-a76'
          # - 'aarch64_generic'
          # - 'arm_arm1176jzf-s_vfp'
          # - 'arm_arm926ej-s'
          # - 'arm_cortex-a15_neon-vfpv4'
          # - 'arm_cortex-a5_vfpv4'
          # - 'arm_cortex-a7'
          # - 'arm_cortex-a7_neon-vfpv4'
          # - 'arm_cortex-a7_vfpv4'
          # - 'arm_cortex-a8_vfpv3'
          # - 'arm_cortex-a9'
          # - 'arm_cortex-a9_neon'
          # - 'arm_cortex-a9_vfpv3-d16'
          # - 'arm_fa526'
          # - 'arm_xscale'
          # - 'i386_pentium-mmx'
          # - 'i386_pentium4'
          # - 'loongarch64_generic'
          # - 'mips64_mips64r2'
          # - 'mips64_octeonplus'
          # - 'mips64el_mips64r2'
          # - 'mips_24kc'
          # - 'mips_4kec'
          # - 'mips_mips32'
          # - 'mipsel_24kc'
          # - 'mipsel_24kc_24kf'
          # - 'mipsel_74kc'
          # - 'mipsel_mips32'
          # - 'riscv64_riscv64'
          - 'x86_64'
      fail-fast: true

    steps:

      # PREPARE

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: develop
          path: repo

      - name: Set build version
        id: get_build_version
        run: |
          VERSION=$(sed -n 's/^PKG_VERSION:=\(.*\)/\1/p' repo/package/tailscale/Makefile | tr -d '[:space:]')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          

          echo "Parsed version: $VERSION"

          echo "Directories prepared:"
          ls -la

      - name: Set build timestamp
        id: get_build_date
        run: |
          echo "date=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

      - name: Prepare build scripts, package files, and keys
        env:
          USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
          RSA_SECRET_KEY_B64: ${{ secrets.RSA_SECRET_KEY_B64 }}
        run: |
          mkdir build_scripts
          cp repo/build_scripts/*.sh build_scripts/

          mkdir tailscale
          cp -r repo/package/tailscale/. tailscale/
          
          mkdir keys
          echo "$USIGN_SECRET_KEY_B64" | base64 -d > keys/key-build.sec
          echo "$RSA_SECRET_KEY_B64" | base64 -d > keys/key-build.rsa

      - name: Restore UPX Cache
        uses: actions/cache@v4
        id: cache-upx
        with:
          path: upx
          key: upx-linux-amd64-${{ needs.prepare-tools.outputs.upx_ver }}

      - name: Restore Go Cache
        uses: actions/cache@v4
        id: cache-go
        with:
          path: go
          key: go-linux-amd64-${{ needs.prepare-tools.outputs.go_version }}

      - name: Pull OpenWRT 24.10 SDK Docker image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_IPK_SDK }}

      - name: Pull OpenWRT 25.12 SDK Docker image
        run: |
          docker pull ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_APK_SDK }}

      # BUILD

      - name: Prepare directories and permissions
        run: |
          mkdir -p bin
          mkdir -p "${{ env.ARTIFACT_DIR }}"
          chmod -R 777 bin || true
          echo "Directories prepared with permissions:"
          ls -la

      - name: Build with OpenWRT 24.10 SDK Docker
        run: |
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/build_scripts:/builder/build_scripts:ro,z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "$(pwd)/keys:/builder/keys:ro,z" \
            -v "$(pwd)/upx:/builder/upx:ro,z" \
            -v "$(pwd)/go:/builder/go:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_IPK_SDK }} \
            bash /builder/build_scripts/build_ipk.sh

      - name: Build with OpenWRT 25.12 SDK Docker
        run: |
          docker run --rm \
            -v "$(pwd)/bin:/builder/bin:z" \
            -v "$(pwd)/build_scripts:/builder/build_scripts:ro,z" \
            -v "$(pwd)/tailscale:/builder/tailscale:ro,z" \
            -v "$(pwd)/keys:/builder/keys:ro,z" \
            -v "$(pwd)/upx:/builder/upx:ro,z" \
            -v "$(pwd)/go:/builder/go:ro,z" \
            -e TERM=xterm \
            -e FORCE=1 \
            ghcr.io/openwrt/sdk:${{ matrix.platform }}-V${{ env.OPENWRT_APK_SDK }} \
            bash /builder/build_scripts/build_apk.sh

      # - name: Setup tmate session
      #   uses: mxschmitt/action-tmate@v3
      #   if: always() && failure()
        
      - name: Clean up build scripts and keys
        run: |
          rm -rf build_scripts
          rm -rf tailscale
          rm -rf keys
      
      # UPLOAD

      - name: Collect build artifacts
        shell: bash
        run: |
          mkdir -p "${{ env.ARTIFACT_DIR }}"

          cp -v bin/packages/* "${{ env.ARTIFACT_DIR }}/" 2>/dev/null || true

          # echo "Searching for IPK for platform: ${{ matrix.platform }}..."
          
          # if [ -d "bin/packages/${{ matrix.platform }}" ]; then
          #   mapfile -t ipk_files < <(find "bin/packages/${{ matrix.platform }}" -name "tailscale_*.ipk" -type f)
          # else
          #   mapfile -t ipk_files < <(find bin -name "tailscale_*.ipk" -type f)
          # fi

          # if [ ${#ipk_files[@]} -eq 0 ]; then
          #   echo "::error::No IPK files found for ${{ matrix.platform }}!"
          #   exit 1
          # fi

          # source_ipk=$(ls -t "${ipk_files[@]}" | head -n 1)
          
          # target_ipk="${{ env.ARTIFACT_DIR }}/tailscale_${{ steps.get_build_version.outputs.version }}_${{ matrix.platform }}.ipk"

          # echo "Found IPK: $source_ipk"
          # echo "Collecting to: $target_ipk"
          
          # cp -v "$source_ipk" "$target_ipk"

          # if [ ! -s "$target_ipk" ]; then
          #   echo "::error::Artifact collection failed: $target_ipk is missing or empty!"
          #   exit 1
          # fi

          # echo "Success: Artifact ready in ${{ env.ARTIFACT_DIR }}"
          # ls -lh "${{ env.ARTIFACT_DIR }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tailscale_${{ steps.get_build_version.outputs.version }}_${{ matrix.platform }}
          path: ${{ env.ARTIFACT_DIR }}/
          if-no-files-found: error
          retention-days: 30

  # release:
  #   name: Create Release
  #   needs: [build]
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: write
  #   env:
  #     RELEASE_TAG: v${{ needs.build.outputs.version }}
  #     VERSION: ${{ needs.build.outputs.version }}
  #     BUILD_DATE: ${{ needs.build.outputs.date }}
  #     ARTIFACT_DIR: "release_assets"
  #   steps:
  #     - name: Prepare workspace
  #       run: mkdir -p ${{ env.ARTIFACT_DIR }}

  #     - name: Download artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         path: temp_artifacts

  #     - name: Organize and Generate Files
  #       run: |
  #         JSON_FILE="${{ env.ARTIFACT_DIR }}/artifacts.json"
  #         PACKAGES_FILE="${{ env.ARTIFACT_DIR }}/Packages"
          
  #         echo "[" > "$JSON_FILE"
  #         : > "$PACKAGES_FILE" # 使用 : > 清空文件更简洁
          
  #         first=true
  #         # 遍历所有下载的 artifacts 目录
  #         for dir in temp_artifacts/*/; do
  #           [ -d "$dir" ] || continue
            
  #           ipk_path=$(find "$dir" -name "tailscale_*.ipk" -type f | head -n 1)
  #           [ -z "$ipk_path" ] && continue
            
  #           ipk_name=$(basename "$ipk_path")
            
  #           # 改进后的架构提取逻辑：提取第3个下划线之后的部分
  #           arch=$(echo "$ipk_name" | cut -d'_' -f3- | sed 's/\.ipk$//')
            
  #           # 复制 IPK 到发布目录
  #           cp "$ipk_path" "${{ env.ARTIFACT_DIR }}/"
            
  #           echo "Processing $ipk_name for $arch..."
            
  #           # 提取 control 内容
  #           CONTROL_CONTENT=$(tar -xOzf "$ipk_path" ./control.tar.gz | tar -xOzf - ./control 2>/dev/null || \
  #                             tar -xOzf "$ipk_path" control.tar.gz | tar -xOzf - control)
  #           # 计算文件大小和 SHA256
  #           FILE_SIZE=$(stat -c%s "$ipk_path")
  #           FILE_SHA256=$(sha256sum "$ipk_path" | awk '{print $1}')
            
  #           # 组合写入 Packages
  #           # 使用 sed 确保每个 control 段落后都有换行符，避免字段粘连
  #           {
  #             echo "$CONTROL_CONTENT" | sed '$a\' 
  #             echo "Filename: $ipk_name"
  #             echo "Size: $FILE_SIZE"
  #             echo "SHA256sum: $FILE_SHA256"
  #             echo "" 
  #           } >> "$PACKAGES_FILE"
            
  #           # 写入 JSON
  #           if [ "$first" = true ]; then
  #             first=false
  #           else
  #             echo "," >> "$JSON_FILE"
  #           fi
  #           echo "{\"target\":\"${arch}\",\"ipk\":\"${ipk_name}\",\"sha256\":\"${FILE_SHA256}\"}" >> "$JSON_FILE"
  #         done
          
  #         echo "]" >> "$JSON_FILE"

  #         echo "${{ env.VERSION }}" > "${{ env.ARTIFACT_DIR }}/version"
          
  #         # 生成 Packages.gz
  #         gzip -kf "$PACKAGES_FILE"
      
  #     - name: Setup Usign
  #       run: |
  #         git clone --depth 1 https://git.openwrt.org/project/usign.git
  #         cd usign && mkdir build && cd build
  #         cmake .. && make -j$(nproc) && sudo make install

  #     - name: Deploy to Feed Branch
  #       env:
  #         USIGN_SECRET_KEY_B64: ${{ secrets.USIGN_SECRET_KEY_B64 }}
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         # 1. 配置 Git 用户信息
  #         git config --global user.name "github-actions[bot]"
  #         git config --global user.email "github-actions[bot]@users.noreply.github.com"

  #         # 删除本地 feed 分支
  #         mkdir deploy_workspace
  #         cd deploy_workspace
  #         git init

  #         git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
  #         git checkout --orphan feed

  #         # 创建 orphan 分支
  #         git fetch origin main --depth=1
  #         git checkout origin/main -- feed_template/

  #         cp -r feed_template/* ./
  #         rm -rf feed_template

  #         # 创建 .nojekyll
  #         touch .nojekyll
          
  #         # 拷贝新生成的文件
  #         cp ../${{ env.ARTIFACT_DIR }}/tailscale_*.ipk ./
  #         cp ../${{ env.ARTIFACT_DIR }}/Packages ./
  #         cp ../${{ env.ARTIFACT_DIR }}/Packages.gz ./

  #         # 签名逻辑
  #         echo "$USIGN_SECRET_KEY_B64" | base64 -d > key-build.sec
  #         usign -S -m Packages -s key-build.sec -x Packages.sig
  #         rm -f key-build.sec

  #         generate_tbody() {
  #           echo "          <tbody>"
  #           for file in Packages* tailscale*; do
  #             [ -f "${file}" ] || continue
  #             fname=$(basename "${file}")
  #             fsize=$(du -h "${file}" | cut -f1)
  #             fdate=$(date -r "${file}" +"%Y-%m-%d %a %H:%M:%S UTC")
  #             echo "                        <tr>"
  #             echo "                            <td><a href=\"$fname\">$fname</a></td>"
  #             echo "                            <td>$fsize</td>"
  #             echo "                            <td>$fdate</td>"
  #             echo "                        </tr>"
  #           done
  #           echo "          </tbody>"
  #         }

          
  #         generate_tbody > tbody.tmp
  #         sed -i '/<!-- tbody-anchor -->/,/<!-- end-tbody-anchor -->/ {
  #           /<!-- tbody-anchor -->/!{
  #             /<!-- end-tbody-anchor -->/!d
  #           }
  #         }' index.html
  #         sed -i '/<!-- tbody-anchor -->/r tbody.tmp' index.html
            
  #         current_date="${{ env.BUILD_DATE }}"
  #         sed -i '/<!-- date-anchor -->/,/<!-- end-date-anchor -->/ {
  #             /<span id="date">/ {
  #                 s#<span id="date">.*</span>#<span id="date">'"${current_date}"'</span>#
  #             }
  #         }' index.html

  #         version=$(echo "${{ env.RELEASE_TAG }}" | sed 's/^v//')
  #         sed -i '/<!-- version-anchor -->/,/<!-- end-version-anchor -->/ {
  #             /<span id="version">/ {
  #                 s#<span id="version">.*</span>#<span id="version">'"${version}"'</span>#
  #             }
  #         }' index.html

  #         rm -f tbody.tmp

  #         git add -A
  #         git commit -m "Update feed: ${{ env.BUILD_DATE }}"
  #         git push origin feed --force

  #     - name: Generate release markdown
  #       id: generate_release_markdown
  #       run: |
  #         # 读取 artifacts.json 并生成简单的 markdown 表格
  #         artifacts_file="${{ env.ARTIFACT_DIR }}/artifacts.json"
  #         if [[ ! -f "${artifacts_file}" ]]; then
  #           echo "Error: artifacts.json missing"
  #           exit 1
  #         fi
          
  #         owner="${{ env.REPO_SMALL_OWNER }}"
  #         repo="${{ env.REPO_SMALL_NAME }}"
  #         tag="${{ env.RELEASE_TAG }}"
          
  #         # 构建 Markdown 表格
  #         table="| Target Platform / 目标平台 | IPK Package (Direct Link) |\n|:--- |:--- |"
  #         rows=$(jq -r --arg owner "$owner" --arg repo "$repo" --arg tag "$tag" '
  #         .[] | "| \(.target) | [\(.ipk)](https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\(.ipk)) |"
  #         ' ${artifacts_file})
  #         full_table="${table}\n${rows}"

  #         # 设置 Release Body
  #         release_body="
  #         ## Smaller Tailscale / 更小的Tailscale  
  #         #### Version / 版本 : ${{ env.RELEASE_TAG }}
  #         #### Build Date / 构建日期 : ${{ env.BUILD_DATE }}
  #         #### Upstream Changelog / 上游更新日志 : [https://tailscale.com/changelog](https://tailscale.com/changelog)
  #         ---

  #         #### 本项目是为 OpenWRT 构建的 Tailscale 精简版本，使用官方 SDK 编译，旨在降低存储空间占用。    
  #         - 使用 OpenWRT 官方 SDK 编译。  
  #         - 采用 UPX 压缩技术大幅缩小二进制体积。  
  #         - 标准 IPK 格式，支持 opkg 直接安装。  

  #         #### Minimalistic Tailscale build for OpenWRT using the official SDK.  
  #         - Compiled with official OpenWRT SDK.  
  #         - Significant size reduction via UPX compression.  
  #         - Standard IPK format for direct opkg installation.  

  #         #### Architecture Check / 架构查询  
  #         Run the following command on your device to confirm target platform:  
  #         \`\`\`bash
  #         opkg print-architecture
  #         \`\`\`

  #         ---
        
  #         #### Download Links / 下载清单
  #         > [!IMPORTANT]
  #         > 请根据设备架构选择对应的安装包。
  #         > Please select the correct package for your device architecture.

  #         <details open>
  #         <summary>Package List / 文件列表</summary>

  #         ${full_table}

  #         </details>
  #         "

  #         echo "release_body<<EOF" >> $GITHUB_OUTPUT
  #         echo -e "${release_body}" >> $GITHUB_OUTPUT
  #         echo "EOF" >> $GITHUB_OUTPUT

  #     - name: Create GitHub Release
  #       uses: softprops/action-gh-release@v1
  #       with:
  #         tag_name: ${{ env.RELEASE_TAG }}
  #         name: "Smaller ${{ env.SOFTWARE_NAME }} ${{ env.RELEASE_TAG }}"
  #         body: ${{ steps.generate_release_markdown.outputs.release_body }}
  #         files: |
  #           ${{ env.ARTIFACT_DIR }}/*.ipk
  #           ${{ env.ARTIFACT_DIR }}/Packages
  #           ${{ env.ARTIFACT_DIR }}/Packages.gz
  #           ${{ env.ARTIFACT_DIR }}/artifacts.json
  #           ${{ env.ARTIFACT_DIR }}/version

  #     - name: Sync to small repo
  #       uses: actions/github-script@v6
  #       with:
  #         script: |
  #           await github.rest.git.createTag({
  #             owner: '${{ env.REPO_SMALL_OWNER }}',
  #             repo: '${{ env.REPO_SMALL_NAME }}',
  #             tag: '${{ env.RELEASE_TAG }}',
  #             message: 'Release ${{ env.RELEASE_TAG }}',
  #             object: '${{ github.sha }}',
  #             type: 'commit'
  #           })